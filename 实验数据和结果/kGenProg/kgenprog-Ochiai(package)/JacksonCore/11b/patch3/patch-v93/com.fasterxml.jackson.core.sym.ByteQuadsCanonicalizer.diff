--- com.fasterxml.jackson.core.sym.ByteQuadsCanonicalizer
+++ com.fasterxml.jackson.core.sym.ByteQuadsCanonicalizer
@@ -483,8 +483,6 @@
         // secondary? single slot shared by N/2 primaries
         int offset2 = _secondaryStart + ((offset >> 3) << 2);
 
-        len = hashArea[offset2+3];
-
         if (len == 1) {
             if (hashArea[offset2] == q1) {
                 return _names[offset2 >> 2];
@@ -822,7 +820,6 @@
         {
                 offset = _findOffsetForAdd(calcHash(q[0]));
                 _hashArea[offset] = q[0];
-                _hashArea[offset+3] = 1;
             }
             break;
         case 2:
@@ -980,7 +977,8 @@
     public int calcHash(int q1)
     {
         int hash = q1 ^ _seed;
-        /* 29-Mar-2015, tatu: Earlier used 15 + 9 right shifts, which worked ok
+        final int[] hashArea = _hashArea;
+		/* 29-Mar-2015, tatu: Earlier used 15 + 9 right shifts, which worked ok
          *    except for one specific problem case: numbers. So needed to make sure
          *    that all 4 least-significant bits participate in hash. Couple of ways
          *    to work it out, but this is the simplest, fast and seems to do ok.
