--- com.fasterxml.jackson.core.sym.ByteQuadsCanonicalizer
+++ com.fasterxml.jackson.core.sym.ByteQuadsCanonicalizer
@@ -929,7 +929,8 @@
         final int end = (_hashSize << 3);
         if (_spilloverEnd >= end) {
             if (_failOnDoS) {
-                _reportTooManyCollisions();
+                _hashShared = true;
+				_reportTooManyCollisions();
             }
             // and if we didn't fail, we'll simply force rehash for next add
             // (which, in turn, may double up or nuke contents, depending on size etc)
@@ -980,12 +981,6 @@
     public int calcHash(int q1)
     {
         int hash = q1 ^ _seed;
-        /* 29-Mar-2015, tatu: Earlier used 15 + 9 right shifts, which worked ok
-         *    except for one specific problem case: numbers. So needed to make sure
-         *    that all 4 least-significant bits participate in hash. Couple of ways
-         *    to work it out, but this is the simplest, fast and seems to do ok.
-         */
-        hash += (hash >>> 16); // to xor hi- and low- 16-bits
         hash ^= (hash << 3); // shuffle back a bit
         hash += (hash >>> 12); // and bit more
         return hash;
